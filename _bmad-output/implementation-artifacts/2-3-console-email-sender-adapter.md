# Story 2.3: Console Email Sender Adapter

Status: review

## Story

As a Technical Evaluator,
I want verification codes to appear in console logs,
So that I can complete the Trust Loop without a real email server.

## Acceptance Criteria

1. **AC1: Adapter Implements Protocol**
   - **Given** `src/adapters/smtp/console.py` exists
   - **When** I inspect the module
   - **Then** `ConsoleEmailSender` class exists
   - **And** it implements `EmailSender` protocol from `src/domain/ports.py`
   - **And** it uses structural subtyping (no explicit inheritance from Protocol)

2. **AC2: Send Verification Code Method**
   - **Given** `send_verification_code(email: str, code: str)` is called
   - **When** the method executes
   - **Then** the verification code is printed to stdout (NFR-O3)
   - **And** uses Python's standard logging module
   - **And** log level is INFO (visible by default)

3. **AC3: Output Format**
   - **Given** a verification code is sent
   - **When** I inspect the console output
   - **Then** the format is clearly visible: `[VERIFICATION] Email: user@example.com Code: 1234`
   - **And** the code is visible in `docker-compose logs`
   - **And** the format is consistent and parseable

4. **AC4: No Side Effects**
   - **Given** the console adapter is used
   - **When** `send_verification_code()` is called
   - **Then** no actual email is sent
   - **And** no external network connections are made
   - **And** the method returns `None` (fire-and-forget)

5. **AC5: Thread Safety**
   - **Given** multiple concurrent registrations occur
   - **When** verification codes are logged
   - **Then** log messages are not interleaved
   - **And** Python's logging module handles thread safety

## Tasks / Subtasks

- [x] Task 1: Create ConsoleEmailSender Class (AC: 1)
  - [x] 1.1: Create `src/adapters/smtp/console.py` file
  - [x] 1.2: Define `ConsoleEmailSender` class
  - [x] 1.3: Add class docstring referencing EmailSender protocol
  - [x] 1.4: Import logging module and create logger instance

- [x] Task 2: Implement send_verification_code Method (AC: 2, 3, 4)
  - [x] 2.1: Add `send_verification_code(self, email: str, code: str) -> None` method signature
  - [x] 2.2: Log verification code at INFO level with specified format
  - [x] 2.3: Format: `[VERIFICATION] Email: {email} Code: {code}`
  - [x] 2.4: Add method docstring explaining console simulation

- [x] Task 3: Write Unit Tests (AC: 1, 2, 3, 4, 5)
  - [x] 3.1: Create `tests/unit/test_console_email_sender.py`
  - [x] 3.2: Test method executes without errors
  - [x] 3.3: Test log output format using caplog fixture
  - [x] 3.4: Test protocol compliance (structural subtyping)
  - [x] 3.5: Test thread safety with concurrent calls

- [x] Task 4: Update Exports and Verify (AC: all)
  - [x] 4.1: Export `ConsoleEmailSender` from `src/adapters/smtp/__init__.py`
  - [x] 4.2: Verify protocol compliance (implements EmailSender)
  - [x] 4.3: Run all tests to ensure no regressions

## Dev Notes

### Current State (from Story 2.1 and 2.2)

The domain layer is complete with:
- `EmailSender` protocol in `src/domain/ports.py`:
  ```python
  class EmailSender(Protocol):
      def send_verification_code(self, email: str, code: str) -> None:
          """Send verification code to email address."""
          ...
  ```
- `RegistrationService` using `EmailSender` via dependency injection
- Verification code is 4-digit string generated by domain layer

The smtp adapter directory exists with stub files:
```
src/adapters/smtp/
├── __init__.py       # Package initialization (stub)
└── console.py        # Stub with docstring only
```

### Architecture Patterns (CRITICAL)

From `architecture.md` - Adapter Implementation Pattern:

```python
# src/adapters/smtp/console.py
import logging

logger = logging.getLogger(__name__)


class ConsoleEmailSender:
    """
    Implements EmailSender protocol via console logging.

    Uses structural subtyping - no explicit inheritance from Protocol.
    For demo/development purposes - prints verification codes to stdout.
    """

    def send_verification_code(self, email: str, code: str) -> None:
        """
        Log verification code to console (simulates email delivery).

        In production, this would be replaced with an SMTP adapter.
        The code is logged at INFO level to be visible in docker-compose logs.

        Args:
            email: Recipient email address (normalized by domain layer)
            code: 4-digit verification code
        """
        logger.info("[VERIFICATION] Email: %s Code: %s", email, code)
```

**Key Pattern Notes:**
- Uses `logging.getLogger(__name__)` for proper log hierarchy
- Uses `%s` formatting (not f-strings) for logging best practices
- Structural subtyping - no `class ConsoleEmailSender(EmailSender)`
- Method signature matches protocol exactly

### Logging Configuration Context

From `src/api/main.py` (Epic 1), logging is configured:
```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
```

This ensures:
- INFO level messages are displayed by default
- Timestamps are included for debugging
- Logger name identifies the source module

### Testing Pattern

Unit tests should capture log output:

```python
# tests/unit/test_console_email_sender.py
import logging
import pytest
from src.adapters.smtp.console import ConsoleEmailSender


class TestConsoleEmailSender:
    def test_send_verification_code_logs_message(self, caplog):
        """Verification code is logged at INFO level."""
        sender = ConsoleEmailSender()

        with caplog.at_level(logging.INFO):
            sender.send_verification_code("test@example.com", "1234")

        assert len(caplog.records) == 1
        assert "[VERIFICATION]" in caplog.text
        assert "test@example.com" in caplog.text
        assert "1234" in caplog.text

    def test_send_verification_code_format(self, caplog):
        """Log format matches specification."""
        sender = ConsoleEmailSender()

        with caplog.at_level(logging.INFO):
            sender.send_verification_code("user@example.com", "5678")

        assert "Email: user@example.com" in caplog.text
        assert "Code: 5678" in caplog.text

    def test_implements_email_sender_protocol(self):
        """ConsoleEmailSender implements EmailSender protocol."""
        from src.domain.ports import EmailSender

        sender = ConsoleEmailSender()
        # Protocol check - has required method with correct signature
        assert hasattr(sender, "send_verification_code")
        assert callable(sender.send_verification_code)
```

### Thread Safety Verification

Python's logging module is thread-safe by design. Test with concurrent calls:

```python
from concurrent.futures import ThreadPoolExecutor

def test_concurrent_logging_is_thread_safe(self, caplog):
    """Multiple concurrent calls don't corrupt log output."""
    sender = ConsoleEmailSender()
    emails = [f"user{i}@example.com" for i in range(10)]
    codes = [f"{i:04d}" for i in range(10)]

    with caplog.at_level(logging.INFO):
        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = [
                executor.submit(sender.send_verification_code, email, code)
                for email, code in zip(emails, codes)
            ]
            for f in futures:
                f.result()

    # All 10 messages should be logged
    assert len(caplog.records) == 10
    # Each message should be complete (not interleaved)
    for record in caplog.records:
        assert "[VERIFICATION]" in record.message
        assert "Email:" in record.message
        assert "Code:" in record.message
```

### Directory Structure After This Story

```
src/adapters/smtp/
├── __init__.py       # Export ConsoleEmailSender [UPDATED]
└── console.py        # ConsoleEmailSender implementation [UPDATED]

tests/unit/
├── test_registration_service.py   # Existing from Story 2.1
├── test_domain_ports.py           # Existing from Story 2.1
└── test_console_email_sender.py   # [NEW] Console adapter tests
```

### Security Considerations

1. **No Sensitive Data in Production Logs**
   - For demo purposes, verification codes ARE logged
   - In production, replace with real SMTP adapter that doesn't log codes
   - NFR-O3 explicitly requires visible codes for demo

2. **Email Normalization**
   - Email is already normalized by domain layer (Story 2.1)
   - Adapter receives `user@example.com`, not `USER@Example.COM`

3. **No External Connections**
   - Console adapter makes no network calls
   - Safe for offline development/testing

### Previous Story Learnings

From Story 2.1:
- Domain layer calls `email_sender.send_verification_code(normalized_email, code)`
- Email is normalized (lowercase, stripped) before reaching adapter
- Verification code is 4-digit string from secrets module
- Use structural subtyping (no Protocol inheritance)

From Story 2.2:
- Combined nested `with` statements to fix Ruff SIM117
- Run `ruff check` and `ruff format` before marking complete
- Use pytest fixtures for test setup

From Epic 1 Code Review:
- Always run `ruff check --fix` and `ruff format` before done
- Use pytest fixtures for test isolation
- Add proper type hints to all public functions

### Integration with RegistrationService

The console adapter will be wired to `RegistrationService` in Story 2.4:

```python
# In src/api/dependencies.py (Story 2.4)
from src.adapters.smtp.console import ConsoleEmailSender

def get_email_sender() -> ConsoleEmailSender:
    return ConsoleEmailSender()

def get_registration_service(
    repository: PostgresRegistrationRepository = Depends(get_repository),
    email_sender: ConsoleEmailSender = Depends(get_email_sender),
) -> RegistrationService:
    return RegistrationService(repository=repository, email_sender=email_sender)
```

### Dependencies

**Story 2.3 depends on:**
- Story 2.1 (Domain layer with EmailSender protocol) ✅ Complete

**Stories depending on 2.3:**
- Story 2.4 (Register API Endpoint) - uses ConsoleEmailSender via DI

### References

- [Source: architecture.md#Structure Patterns]
- [Source: architecture.md#Port Interface Patterns]
- [Source: prd.md#FR5]
- [Source: prd.md#NFR-O3]
- [Source: epics.md#Story 2.3]

## Dev Agent Record

### Agent Model Used

Claude Opus 4.5 (claude-opus-4-5-20251101)

### Debug Log References

None - implementation proceeded without issues.

### Completion Notes List

1. Created `ConsoleEmailSender` class implementing `EmailSender` protocol via structural subtyping
2. Implemented `send_verification_code()` method using Python's logging module at INFO level
3. Log format: `[VERIFICATION] Email: {email} Code: {code}` - parseable and visible in docker-compose logs
4. Uses `%s` formatting (not f-strings) for logging best practices
5. No explicit Protocol inheritance - verified by checking `__bases__ == (object,)`
6. Created comprehensive unit tests (11 tests) covering:
   - Protocol compliance via structural subtyping
   - Log output format verification using pytest caplog fixture
   - Return value (None - fire-and-forget)
   - Various email and code formats
   - No side effects (no external connections)
   - Thread safety with concurrent calls (ThreadPoolExecutor)
7. Fixed Ruff SIM117 errors: combined nested `with` statements
8. Fixed Ruff B905 error: added `strict=True` to `zip()`
9. All 74 unit tests passing; ruff check and format passing

### File List

**Modified:**
- `src/adapters/smtp/console.py` - Added `ConsoleEmailSender` class with `send_verification_code()` method
- `src/adapters/smtp/__init__.py` - Added export for `ConsoleEmailSender`

**Created:**
- `tests/unit/test_console_email_sender.py` - 11 unit tests for console email sender

